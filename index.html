<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <!-- PWA Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Synchrony Test">
  <meta name="theme-color" content="#1f2937">
  
  <title>Synchrony Perception Test</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="./manifest.json">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    /* Force hardware acceleration */
    * {
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    
    /* Prevent pull-to-refresh on test screens only */
    body {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Only lock scrolling during actual test trials */
    body.no-scroll {
      position: fixed;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: pan-x pan-y;
    }
    
    /* Force GPU acceleration on all elements */
    #root {
      will-change: transform;
      transform: translateZ(0);
    }
    
    /* Safari 120Hz hack - constant animation forces high refresh rate */
    .safari-120hz-hack {
      width: 1px;
      height: 1px;
      opacity: 0.01;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      animation: jitter 0.008333s infinite linear;
      will-change: transform;
    }
    
    @keyframes jitter {
      0% { transform: translateY(0) translateZ(0); }
      50% { transform: translateY(0.5px) translateZ(0); }
      100% { transform: translateY(0) translateZ(0); }
    }
  </style>
</head>
<body>
  <!-- Safari 120Hz hack - invisible constantly animating element -->
  <div class="safari-120hz-hack"></div>
  
  <div id="root"></div>
  
  <!-- React and Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('Service Worker registered'))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
  
  <!-- React Component - Embedded Directly -->
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    function SynchronyTest() {
      const [phase, setPhase] = useState('intro');
      const [fps, setFps] = useState(0);
      const [is120Hz, setIs120Hz] = useState(false);
      const [currentTrial, setCurrentTrial] = useState(-1);
      const [results, setResults] = useState([]);
      const [trials, setTrials] = useState([]);
      const [animationOffset, setAnimationOffset] = useState(0);

      // DOM Refs for direct manipulation (Bypasses React render lag)
      const leftEmojiRef = useRef(null);
      const rightEmojiRef = useRef(null);
      
      // Create a reusable audio context for haptic feedback
      const audioContextRef = useRef(null);
      
      useEffect(() => {
        // Initialize audio context on user interaction
        const initAudio = () => {
          if (!audioContextRef.current) {
            audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
          }
        };
        document.addEventListener('touchstart', initAudio, { once: true });
        return () => document.removeEventListener('touchstart', initAudio);
      }, []);

      const timerRef = useRef(null);
      const hasRespondedRef = useRef(false);
      const flashEndTimeRef = useRef(0);

      // Frame-perfect offsets for 120Hz displays  
      // At 120Hz, each frame is 8.333ms
      // 
      // Using EXACT frame boundary values because:
      // - The condition is `elapsed >= offsetMs`
      // - At frame N, elapsed will be exactly N * 8.333ms
      // - So offsetMs = 8.333 will trigger when elapsed reaches 8.333ms (frame 1)
      //
      // Example: offset = 8.333ms
      //   Frame 0 (elapsed=0ms):     0 < 8.333 → block2 hidden
      //   Frame 1 (elapsed=8.333ms): 8.333 >= 8.333 → block2 shows ✓
      //
      // JavaScript timing jitter is handled by requestAnimationFrame
      // which always fires at exact frame boundaries (0, 8.333, 16.667, ...)
      const FRAME_MS = 1000 / 120; // 8.333... ms
      
      const offsets = [
        0,              // 0 frames - simultaneous  
        FRAME_MS * 1,   // 1 frame delay (8.333ms) - left first
        -FRAME_MS * 1,  // 1 frame delay (8.333ms) - right first
        FRAME_MS * 2,   // 2 frames delay (16.667ms) - left first
        -FRAME_MS * 2,  // 2 frames delay (16.667ms) - right first
        FRAME_MS * 3,   // 3 frames delay (25.000ms) - left first
        -FRAME_MS * 3,  // 3 frames delay (25.000ms) - right first
        FRAME_MS * 4,   // 4 frames delay (33.333ms) - left first
        -FRAME_MS * 4,  // 4 frames delay (33.333ms) - right first
        FRAME_MS * 5,   // 5 frames delay (41.667ms) - left first
        -FRAME_MS * 5,  // 5 frames delay (41.667ms) - right first
        FRAME_MS * 6,   // 6 frames delay (50.000ms) - left first
        -FRAME_MS * 6   // 6 frames delay (50.000ms) - right first
      ];

      useEffect(() => {
        const trialList = [...offsets].sort(() => Math.random() - 0.5);
        setTrials(trialList);
      }, []);

      // Frame Rate Detection Logic - CONTINUOUS
      useEffect(() => {
        let frameCount = 0;
        let startTime = performance.now();
        let rafId;
        
        const checkFps = (now) => {
          frameCount++;
          const elapsed = now - startTime;
          if (elapsed >= 1000) {
            const currentFps = Math.round((frameCount * 1000) / elapsed);
            setFps(currentFps);
            setIs120Hz(currentFps > 100); // Threshold for ProMotion
            
            // Reset for continuous monitoring
            frameCount = 0;
            startTime = now;
          }
          rafId = requestAnimationFrame(checkFps);
        };
        
        // Always run, not just on intro
        rafId = requestAnimationFrame(checkFps);
        
        return () => {
          if (rafId) cancelAnimationFrame(rafId);
        };
      }, []); // Remove phase dependency to run continuously

      // Stress Test Animation - keeps frame rate elevated
      useEffect(() => {
        let rafId;
        let lastTime = performance.now();
        
        const animate = (currentTime) => {
          const delta = currentTime - lastTime;
          lastTime = currentTime;
          
          // Much faster animation to stress the frame rate
          setAnimationOffset(prev => (prev + delta * 0.2) % 360);
          
          rafId = requestAnimationFrame(animate);
        };
        
        rafId = requestAnimationFrame(animate);
        
        return () => {
          if (rafId) cancelAnimationFrame(rafId);
        };
      }, []);

      const startTest = () => {
        document.body.classList.add('no-scroll');
        setPhase('practice');
        setCurrentTrial(-1);
        // Give the DOM a moment to mount before starting the practice trial
        setTimeout(() => startTrial(-1), 100);
      };

      const startTrial = (trialNum) => {
        hasRespondedRef.current = false;
        const offset = trialNum === -1 ? 0 : trials[trialNum];
        setPhase(trialNum === -1 ? 'practice' : 'fixation');

        // 1. Fixation Period
        timerRef.current = setTimeout(() => {
          runStimulus(offset);
        }, 1500);
      };

      const runStimulus = (offsetMs) => {
        setPhase('stimulus');
        const startTime = performance.now();
        const duration = 100; // Visible duration in ms

        const animate = (currentTime) => {
          const elapsed = currentTime - startTime;

          if (offsetMs >= 0) {
            // Left first (or simultaneous)
            if (leftEmojiRef.current) {
              leftEmojiRef.current.style.opacity = (elapsed >= 0 && elapsed <= duration) ? '1' : '0';
            }
            if (rightEmojiRef.current) {
              rightEmojiRef.current.style.opacity = (elapsed >= offsetMs && elapsed <= offsetMs + duration) ? '1' : '0';
            }
          } else {
            // Right first
            const absOffset = Math.abs(offsetMs);
            if (rightEmojiRef.current) {
              rightEmojiRef.current.style.opacity = (elapsed >= 0 && elapsed <= duration) ? '1' : '0';
            }
            if (leftEmojiRef.current) {
              leftEmojiRef.current.style.opacity = (elapsed >= absOffset && elapsed <= absOffset + duration) ? '1' : '0';
            }
          }

          // Check if the sequence is finished (max offset + duration)
          if (elapsed < Math.abs(offsetMs) + duration + 16) {
            requestAnimationFrame(animate);
          } else {
            flashEndTimeRef.current = performance.now();
            setPhase('response');
          }
        };

        requestAnimationFrame(animate);
      };

      const handleResponse = (response) => {
        if (hasRespondedRef.current || phase !== 'response') return;
        hasRespondedRef.current = true;

        // Haptic feedback - works on Android
        if (navigator.vibrate) {
          navigator.vibrate(10);
        }

        // Audio feedback - works on iOS and Android
        try {
          const audioContext = audioContextRef.current || new (window.AudioContext || window.webkitAudioContext)();
          if (!audioContextRef.current) audioContextRef.current = audioContext;
          
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Short, pleasant click sound
          gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.03);
          
          oscillator.frequency.value = 800; // High pitch for crisp click
          oscillator.type = 'sine';
          
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + 0.03);
        } catch (e) {
          // Silently fail if audio not supported
        }

        const responseTime = performance.now();
        const reactionTimeMs = Math.round(responseTime - flashEndTimeRef.current);

        const offset = currentTrial === -1 ? 0 : trials[currentTrial];
        if (currentTrial >= 0) {
          setResults(prev => [...prev, { 
            trial: currentTrial + 1, 
            offset, 
            response,
            reactionTime: reactionTimeMs,
            fps: fps, // Record FPS at time of response
            timestamp: new Date().toISOString()
          }]);
        }

        if (currentTrial >= trials.length - 1) {
          document.body.classList.remove('no-scroll');
          setPhase('complete');
        } else {
          setPhase('waiting');
          timerRef.current = setTimeout(() => {
            const next = currentTrial + 1;
            setCurrentTrial(next);
            startTrial(next);
          }, 1500);
        }
      };

      // Intro screen
      if (phase === 'intro') {
        return (
          <div className="min-h-screen bg-gray-900 text-white p-6 py-12">
            <div className="max-w-md mx-auto text-center">
              <h1 className="text-3xl font-bold mb-6">Synchrony Perception Test</h1>
              
              {/* FPS Monitor Badge with Stress Test Animation */}
              <div className="mb-6">
                <div className={`inline-block px-4 py-2 rounded-full text-sm font-mono ${is120Hz ? 'bg-green-900 text-green-400' : 'bg-yellow-900 text-yellow-400'}`}>
                  {fps}Hz Detected
                </div>
                
                {/* Spinning stress test indicators */}
                <div className="flex justify-center gap-2 mt-3">
                  {[0, 1, 2, 3, 4].map((i) => (
                    <div
                      key={i}
                      className="w-3 h-3 rounded-full bg-blue-500"
                      style={{
                        transform: `translateY(${Math.sin((animationOffset + i * 72) * Math.PI / 180) * 12}px) translateZ(0)`,
                        opacity: 0.3 + (Math.sin((animationOffset + i * 72) * Math.PI / 180) * 0.5 + 0.5) * 0.7,
                        willChange: 'transform, opacity'
                      }}
                    />
                  ))}
                </div>
              </div>
              
              {!is120Hz && fps > 0 && fps < 100 && (
                <div className="bg-yellow-600/20 border border-yellow-600 text-yellow-200 p-3 rounded-lg mb-6 text-sm">
                  <strong>⚠️ Limited to {fps}Hz</strong><br/>
                  Turn off Low Power Mode and close other apps for best results.
                </div>
              )}
              
              <div className="bg-gray-800 p-6 rounded-lg mb-6 text-left space-y-3">
                <p>Two blue squares will flash briefly.</p>
                <p><span className="text-blue-400 font-bold">SAME</span> = They appeared at the same time</p>
                <p><span className="text-yellow-400 font-bold">LEFT</span> = Left appeared first</p>
                <p><span className="text-green-400 font-bold">RIGHT</span> = Right appeared first</p>
              </div>
              
              <div className="bg-gray-800/50 p-4 rounded-lg mb-6 text-sm space-y-2">
                <p>• Hold device vertically (portrait mode)</p>
                <p>• Three buttons: LEFT, SAME, RIGHT</p>
                <p>• Respond quickly when buttons light up</p>
              </div>
              
              <p className="text-gray-400 text-sm mb-6">1 practice trial + 13 test trials</p>
              
              <button
                onClick={startTest}
                className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-8 rounded-xl text-xl transition-all active:scale-95"
              >
                Start Test
              </button>
            </div>
          </div>
        );
      }

      // Results screen
      if (phase === 'complete') {
        // Create CSV format (just the trial details, no summary table)
        const csvDetails = ['Trial,Offset_ms,Response,ReactionTime_ms,FPS,Timestamp'];
        results.forEach(r => {
          csvDetails.push(`${r.trial},${r.offset},${r.response},${r.reactionTime},${r.fps},${r.timestamp}`);
        });
        const csvText = csvDetails.join('\n');

        // Calculate summary data for histogram
        const uniqueOffsets = [0, 8.333, 16.667, 25.0, 33.333, 41.667, 50.0];
        const summaryData = uniqueOffsets.map(absOffset => {
          const offsetResults = results.filter(r => Math.abs(Math.abs(r.offset) - absOffset) < 0.01);
          const sameCount = offsetResults.filter(r => r.response === 'Same').length;
          const proportion = offsetResults.length > 0 ? sameCount / offsetResults.length : 0;
          return {
            offset: absOffset,
            percentage: Math.round(proportion * 100),
            count: sameCount,
            total: offsetResults.length
          };
        });

        return (
          <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-8">
            <div className="max-w-4xl w-full">
              <h1 className="text-3xl font-bold mb-8 text-center">Test Complete!</h1>
              
              {/* Visual Summary Histogram */}
              <div className="bg-gray-800 rounded-lg p-6 mb-6">
                <h2 className="text-xl font-bold mb-4">Synchrony Perception</h2>
                <p className="text-sm text-gray-400 mb-4">Percentage of trials judged as "SAME" vs absolute offset (ms)</p>
                <div className="space-y-3">
                  {summaryData.map(data => (
                    <div key={data.offset} className="flex items-center gap-3">
                      <div className="w-16 text-right text-sm font-mono">{data.offset.toFixed(1)}ms</div>
                      <div className="flex-1 bg-gray-700 rounded-full h-8 relative overflow-hidden">
                        <div 
                          className="bg-blue-500 h-full rounded-full transition-all duration-500"
                          style={{ width: `${data.percentage}%` }}
                        />
                        <div className="absolute inset-0 flex items-center justify-center text-sm font-bold text-white">
                          {data.percentage}%
                        </div>
                      </div>
                      <div className="w-16 text-left text-xs text-gray-400">
                        {data.count}/{data.total}
                      </div>
                    </div>
                  ))}
                </div>
              </div>
              
              {/* CSV Download */}
              <div className="bg-gray-800 rounded-lg p-6 mb-6">
                <div className="flex justify-between items-center mb-4">
                  <h2 className="text-xl font-bold">Trial Data (CSV)</h2>
                  <button
                    onClick={() => {
                      const blob = new Blob([csvText], { type: 'text/csv' });
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement('a');
                      a.href = url;
                      a.download = `synchrony-test-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.csv`;
                      a.click();
                      URL.revokeObjectURL(url);
                    }}
                    className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
                  >
                    Download CSV
                  </button>
                </div>
                <textarea
                  readOnly
                  value={csvText}
                  className="w-full h-64 bg-gray-900 text-green-400 font-mono text-sm p-4 rounded border border-gray-700 focus:outline-none focus:border-blue-500"
                  onClick={(e) => e.target.select()}
                />
                <p className="mt-2 text-sm text-gray-400">Click inside the box to select all, then Ctrl+C (or Cmd+C) to copy</p>
              </div>
            </div>
          </div>
        );
      }

      // Trial display
      return (
        <div className="flex flex-col items-center justify-start pt-20 min-h-screen text-white select-none touch-none" style={{ willChange: 'transform', backgroundColor: '#FFD700' }}>
          
          {/* Persistent FPS Monitor - Top Right */}
          <div className="fixed top-4 right-4 z-50">
            <div className={`px-3 py-1 rounded-full text-xs font-mono ${is120Hz ? 'bg-green-900/80 text-green-400' : 'bg-red-900/80 text-red-400'}`}>
              {fps}Hz
            </div>
          </div>

          {/* Background animation to maintain 120Hz - invisible but keeps GPU active */}
          <div className="fixed bottom-2 left-1/2 transform -translate-x-1/2 flex gap-1 opacity-20 pointer-events-none">
            {[0, 1, 2].map((i) => (
              <div
                key={i}
                className="w-1 h-1 rounded-full bg-blue-500"
                style={{
                  transform: `translateY(${Math.sin((animationOffset + i * 120) * Math.PI / 180) * 3}px) translateZ(0)`,
                  willChange: 'transform'
                }}
              />
            ))}
          </div>

          <div className="mb-8 text-xl font-bold" style={{ color: '#ffffff' }}>
            {currentTrial === -1 ? (
              <span>Practice Trial</span>
            ) : (
              `Trial ${currentTrial + 1} of ${trials.length}`
            )}
          </div>

          <div className="flex gap-8 items-center justify-center mb-12" style={{ height: '200px' }}>
            <div className="w-32 h-32 flex items-center justify-center border-4 rounded-lg" style={{ borderColor: '#DAA520', backgroundColor: '#FFD700', willChange: 'transform' }}>
              <div ref={leftEmojiRef} className="w-20 h-20 rounded opacity-0 transition-none" style={{ backgroundColor: '#5555FF', filter: 'blur(2px)', willChange: 'opacity', transform: 'translateZ(0)' }}></div>
            </div>
            <div className="w-32 h-32 flex items-center justify-center border-4 rounded-lg" style={{ borderColor: '#DAA520', backgroundColor: '#FFD700', willChange: 'transform' }}>
              <div ref={rightEmojiRef} className="w-20 h-20 rounded opacity-0 transition-none" style={{ backgroundColor: '#5555FF', filter: 'blur(2px)', willChange: 'opacity', transform: 'translateZ(0)' }}></div>
            </div>
          </div>

          {/* Fixed height status area to prevent layout shift */}
          <div className="h-20 mb-4 flex items-center justify-center">
            <div className="flex flex-row gap-3 px-4">
              <button 
                onPointerDown={() => handleResponse('Left')}
                disabled={phase !== 'response'}
                style={{ backgroundColor: '#888888' }}
                className="text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg disabled:cursor-not-allowed">
                LEFT
              </button>
              <button 
                onPointerDown={() => handleResponse('Same')}
                disabled={phase !== 'response'}
                style={{ backgroundColor: '#888888' }}
                className="text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg disabled:cursor-not-allowed">
                SAME
              </button>
              <button 
                onPointerDown={() => handleResponse('Right')}
                disabled={phase !== 'response'}
                style={{ backgroundColor: '#888888' }}
                className="text-white font-bold py-3 px-6 rounded-lg text-lg shadow-lg disabled:cursor-not-allowed">
                RIGHT
              </button>
            </div>
          </div>

          {/* Empty fixed-height area - no distracting text */}
          <div className="h-8"></div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SynchronyTest />);
  </script>
</body>
</html>
