<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <!-- PWA Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Synchrony Test">
  <meta name="theme-color" content="#1f2937">
  
  <title>Synchrony Perception Test</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="./manifest.json">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    /* Force hardware acceleration */
    * {
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    
    /* Prevent pull-to-refresh on test screens only */
    body {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Only lock scrolling during actual test trials */
    body.no-scroll {
      position: fixed;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: pan-x pan-y;
    }
    
    /* Force GPU acceleration on all elements */
    #root {
      will-change: transform;
      transform: translateZ(0);
    }
    
    /* Safari 120Hz hack - constant animation forces high refresh rate */
    .safari-120hz-hack {
      width: 1px;
      height: 1px;
      opacity: 0.01;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      animation: jitter 0.008333s infinite linear;
      will-change: transform;
    }
    
    @keyframes jitter {
      0% { transform: translateY(0) translateZ(0); }
      50% { transform: translateY(0.5px) translateZ(0); }
      100% { transform: translateY(0) translateZ(0); }
    }
  </style>
</head>
<body>
  <!-- Safari 120Hz hack - invisible constantly animating element -->
  <div class="safari-120hz-hack"></div>
  
  <div id="root"></div>
  
  <!-- React and Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('Service Worker registered'))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
  
  <!-- React Component - Embedded Directly -->
  <script type="text/babel">
const { useState, useEffect, useRef } = React;

    function SynchronyTest() {
      const [phase, setPhase] = useState('intro');
      const [fps, setFps] = useState(0);
      const [is120Hz, setIs120Hz] = useState(false);
      const [currentTrial, setCurrentTrial] = useState(-1);
      const [results, setResults] = useState([]);
      const [trials, setTrials] = useState([]);
      
      const [yellowR, setYellowR] = useState(255);
      const [yellowG, setYellowG] = useState(215);
      const [yellowB, setYellowB] = useState(0);
      const [blueR, setBlueR] = useState(85);
      const [blueG, setBlueG] = useState(85);
      const [blueB, setBlueB] = useState(255);

      const leftEmojiRef = useRef(null);
      const rightEmojiRef = useRef(null);
      const audioContextRef = useRef(null);
      const hasRespondedRef = useRef(false);
      const flashEndTimeRef = useRef(0);

      const FRAME_MS = 1000 / 120; 
      
      const offsets = [
        0,
        FRAME_MS * 1,  -FRAME_MS * 1,
        FRAME_MS * 2,  -FRAME_MS * 2,
        FRAME_MS * 3,  -FRAME_MS * 3,
        FRAME_MS * 4,  -FRAME_MS * 4,
        FRAME_MS * 5,  -FRAME_MS * 5,
        FRAME_MS * 6,  -FRAME_MS * 6,
        FRAME_MS * 8,  -FRAME_MS * 8,
        FRAME_MS * 10, -FRAME_MS * 10,
        FRAME_MS * 12, -FRAME_MS * 12
      ];

      useEffect(() => {
        const trialList = [...offsets].sort(() => Math.random() - 0.5);
        setTrials(trialList);
      }, []);

      useEffect(() => {
        let frameCount = 0;
        let startTime = performance.now();
        let rafId;
        const checkFps = (now) => {
          frameCount++;
          const elapsed = now - startTime;
          if (elapsed >= 1000) {
            const currentFps = Math.round((frameCount * 1000) / elapsed);
            setFps(currentFps);
            setIs120Hz(currentFps > 100);
            frameCount = 0;
            startTime = now;
          }
          rafId = requestAnimationFrame(checkFps);
        };
        rafId = requestAnimationFrame(checkFps);
        return () => cancelAnimationFrame(rafId);
      }, []);

      const playHaptic = () => {
        if (navigator.vibrate) navigator.vibrate(15);
        if (audioContextRef.current && audioContextRef.current.state === 'running') {
          const osc = audioContextRef.current.createOscillator();
          const gain = audioContextRef.current.createGain();
          osc.connect(gain);
          gain.connect(audioContextRef.current.destination);
          osc.frequency.setValueAtTime(150, audioContextRef.current.currentTime);
          gain.gain.setValueAtTime(0.1, audioContextRef.current.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, audioContextRef.current.currentTime + 0.1);
          osc.start();
          osc.stop(audioContextRef.current.currentTime + 0.1);
        }
      };

      const startTest = () => {
        if (!audioContextRef.current) {
          audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
        }
        document.body.classList.add('no-scroll');
        setPhase('waiting');
        setCurrentTrial(-1);
        setResults([]);
        runTrial(-1);
      };

      const runTrial = (trialIndex) => {
        const offset = trialIndex === -1 ? 0 : trials[trialIndex];
        hasRespondedRef.current = false;
        setPhase('countdown');
        setTimeout(() => {
          setPhase('flash');
          executeFlash(offset);
        }, 600);
      };

      const gaussPulse = (t, center, width) => {
        const sigma = width / 5;
        return Math.exp(-0.5 * Math.pow((t - center) / sigma, 2));
      };

      const lerpCh = (a, b, w) => Math.round(a + (b - a) * w);

      const executeFlash = (offsetMs) => {
        const startTime = performance.now();
        const DURATION = 100; 
        const absOffset = Math.abs(offsetMs);
        const totalWindow = absOffset + DURATION;
        const firstRef = offsetMs >= 0 ? leftEmojiRef : rightEmojiRef;
        const secondRef = offsetMs >= 0 ? rightEmojiRef : leftEmojiRef;

        const animate = (now) => {
          const elapsed = now - startTime;
          const w1 = gaussPulse(elapsed, DURATION / 2, DURATION);
          const w2 = gaussPulse(elapsed, absOffset + (DURATION / 2), DURATION);

          if (firstRef.current) {
            firstRef.current.style.backgroundColor = 
              `rgb(${lerpCh(yellowR,blueR,w1)},${lerpCh(yellowG,blueG,w1)},${lerpCh(yellowB,blueB,w1)})`;
          }
          if (secondRef.current) {
            secondRef.current.style.backgroundColor = 
              `rgb(${lerpCh(yellowR,blueR,w2)},${lerpCh
  </script>
</body>
</html>
