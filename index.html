<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  
  <!-- PWA Meta Tags -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Synchrony Test">
  <meta name="theme-color" content="#1f2937">
  
  <title>Synchrony Perception Test</title>
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="./manifest.json">
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    /* Force hardware acceleration */
    * {
      -webkit-transform: translateZ(0);
      transform: translateZ(0);
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
    }
    
    /* Prevent pull-to-refresh on test screens only */
    body {
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Only lock scrolling during actual test trials */
    body.no-scroll {
      position: fixed;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: pan-x pan-y;
    }
    
    /* Force GPU acceleration on all elements */
    #root {
      will-change: transform;
      transform: translateZ(0);
    }
    
    /* Safari 120Hz hack - constant animation forces high refresh rate */
    .safari-120hz-hack {
      width: 1px;
      height: 1px;
      opacity: 0.01;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      animation: jitter 0.008333s infinite linear;
      will-change: transform;
    }
    
    @keyframes jitter {
      0% { transform: translateY(0) translateZ(0); }
      50% { transform: translateY(0.5px) translateZ(0); }
      100% { transform: translateY(0) translateZ(0); }
    }
  </style>
</head>
<body>
  <!-- Safari 120Hz hack - invisible constantly animating element -->
  <div class="safari-120hz-hack"></div>
  
  <div id="root"></div>
  
  <!-- React and Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('Service Worker registered'))
          .catch(err => console.log('Service Worker registration failed:', err));
      });
    }
  </script>
  
  <!-- React Component - Embedded Directly -->
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

function SynchronyTest() {
  const [phase, setPhase] = useState('intro');
  const [fps, setFps] = useState(0);
  const [is120Hz, setIs120Hz] = useState(false);
  const [currentTrial, setCurrentTrial] = useState(-1);
  const [results, setResults] = useState([]);
  const [trials, setTrials] = useState([]);
  const [animationOffset, setAnimationOffset] = useState(0);
  
  const [yellowR, setYellowR] = useState(255);
  const [yellowG, setYellowG] = useState(215);
  const [yellowB, setYellowB] = useState(0);
  const [blueR, setBlueR] = useState(85);
  const [blueG, setBlueG] = useState(85);
  const [blueB, setBlueB] = useState(255);

  const leftEmojiRef = useRef(null);
  const rightEmojiRef = useRef(null);
  const audioContextRef = useRef(null);
  
  const FRAME_MS = 1000 / 120; 
  
  const offsets = [
    0,
    FRAME_MS * 1,  -FRAME_MS * 1,
    FRAME_MS * 2,  -FRAME_MS * 2,
    FRAME_MS * 3,  -FRAME_MS * 3,
    FRAME_MS * 4,  -FRAME_MS * 4,
    FRAME_MS * 5,  -FRAME_MS * 5,
    FRAME_MS * 6,  -FRAME_MS * 6,
    FRAME_MS * 8,  -FRAME_MS * 8,
    FRAME_MS * 10, -FRAME_MS * 10,
    FRAME_MS * 12, -FRAME_MS * 12
  ];

  useEffect(() => {
    const trialList = [...offsets].sort(() => Math.random() - 0.5);
    setTrials(trialList);
  }, []);

  useEffect(() => {
    let frameCount = 0;
    let startTime = performance.now();
    let rafId;
    const checkFps = (now) => {
      frameCount++;
      const elapsed = now - startTime;
      if (elapsed >= 1000) {
        const currentFps = Math.round((frameCount * 1000) / elapsed);
        setFps(currentFps);
        setIs120Hz(currentFps > 100);
        frameCount = 0;
        startTime = now;
      }
      rafId = requestAnimationFrame(checkFps);
    };
    rafId = requestAnimationFrame(checkFps);
    return () => cancelAnimationFrame(rafId);
  }, []);

  useEffect(() => {
    let rafId;
    const animate = () => {
      setAnimationOffset(prev => (prev + 8) % 360);
      rafId = requestAnimationFrame(animate);
    };
    rafId = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(rafId);
  }, []);

  const playHaptic = () => {
    if (navigator.vibrate) navigator.vibrate(10);
    if (audioContextRef.current && audioContextRef.current.state === 'running') {
      const osc = audioContextRef.current.createOscillator();
      const gain = audioContextRef.current.createGain();
      osc.connect(gain);
      gain.connect(audioContextRef.current.destination);
      osc.frequency.value = 200;
      gain.gain.setValueAtTime(0.1, audioContextRef.current.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioContextRef.current.currentTime + 0.05);
      osc.start();
      osc.stop(audioContextRef.current.currentTime + 0.05);
    }
  };

  const startTest = () => {
    if (!audioContextRef.current) audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
    document.body.classList.add('no-scroll');
    setPhase('waiting');
    setCurrentTrial(-1);
    setResults([]);
    runTrial(-1);
  };

  const runTrial = (trialIndex) => {
    const offset = trialIndex === -1 ? 0 : trials[trialIndex];
    setPhase('countdown');
    setTimeout(() => {
      setPhase('flash');
      executeFlash(offset);
    }, 500);
  };

  const gaussEnvelope = (t, tStart, tEnd) => {
    if (t <= tStart || t >= tEnd) return 0;
    const dur = tEnd - tStart;
    const mid = tStart + dur / 2;
    const sigma = dur / 5;
    return Math.exp(-0.5 * Math.pow((t - mid) / sigma, 2));
  };

  const lerpCh = (a, b, w) => Math.round(a + (b - a) * w);

  const executeFlash = (offsetMs) => {
    const startTime = performance.now();
    const FLASH_DURATION = 70;
    const absOffset = Math.abs(offsetMs);
    const firstEnd = absOffset + FLASH_DURATION;
    const firstRef = offsetMs >= 0 ? leftEmojiRef : rightEmojiRef;
    const secondRef = offsetMs >= 0 ? rightEmojiRef : leftEmojiRef;

    const animate = (now) => {
      const elapsed = now - startTime;
      const w1 = gaussEnvelope(elapsed, 0, absOffset + FLASH_DURATION);
      const w2 = gaussEnvelope(elapsed, absOffset, absOffset + FLASH_DURATION);

      if (firstRef.current) firstRef.current.style.backgroundColor = `rgb(${lerpCh(yellowR,blueR,w1)},${lerpCh(yellowG,blueG,w1)},${lerpCh(yellowB,blueB,w1)})`;
      if (secondRef.current) secondRef.current.style.backgroundColor = `rgb(${lerpCh(yellowR,blueR,w2)},${lerpCh(yellowG,blueG,w2)},${lerpCh(yellowB,blueB,w2)})`;

      if (elapsed >= firstEnd) {
        const bgStr = `rgb(${yellowR},${yellowG},${yellowB})`;
        if (leftEmojiRef.current) leftEmojiRef.current.style.backgroundColor = bgStr;
        if (rightEmojiRef.current) rightEmojiRef.current.style.backgroundColor = bgStr;
        setPhase('response');
        playHaptic();
        return;
      }
      requestAnimationFrame(animate);
    };
    requestAnimationFrame(animate);
  };

  const handleResponse = (response) => {
    const offset = currentTrial === -1 ? 0 : trials[currentTrial];
    const result = {
      trial: currentTrial === -1 ? 'Practice' : currentTrial + 1,
      offset: offset.toFixed(3),
      response: response,
      fps: fps,
      timestamp: new Date().toISOString()
    };

    if (currentTrial === -1) {
      setCurrentTrial(0);
      runTrial(0);
    } else {
      setResults(prev => [...prev, result]);
      if (currentTrial < trials.length - 1) {
        setCurrentTrial(prev => prev + 1);
        runTrial(currentTrial + 1);
      } else {
        setPhase('complete');
        document.body.classList.remove('no-scroll');
      }
    }
  };

  if (phase === 'intro') {
    return (
      <div className="flex items-center justify-center min-h-screen bg-gray-900 text-white p-6">
        <div className="max-w-2xl w-full">
          <h1 className="text-4xl font-bold mb-4 text-center">Synchrony Perception Test</h1>
          <div className={`mb-6 p-4 rounded-lg text-center ${is120Hz ? 'bg-green-900/30' : 'bg-red-900/30'}`}>
            <p className="text-lg font-bold">Display: {fps}Hz</p>
          </div>
          <button onClick={startTest} className="w-full bg-blue-600 py-4 rounded-xl text-xl font-bold">Start Test</button>
        </div>
      </div>
    );
  }

  if (phase === 'complete') {
    const csvText = "Trial,Offset_ms,Response,FPS,Timestamp\n" + results.map(r => `${r.trial},${r.offset},${r.response},${r.fps},${r.timestamp}`).join('\n');
    const uniqueOffsets = [0, 8.333, 16.667, 25.0, 33.333, 41.667, 50.0, 66.667, 83.333, 100.0];
    
    return (
      <div className="min-h-screen bg-gray-900 text-white p-8">
        <h1 className="text-3xl font-bold mb-8">Results Summary</h1>
        <div className="space-y-4 bg-gray-800 p-6 rounded-xl">
          {uniqueOffsets.map(val => {
            const matches = results.filter(r => Math.abs(Math.abs(parseFloat(r.offset)) - val) < 1);
            const same = matches.filter(r => r.response === 'Same').length;
            const pct = matches.length ? Math.round((same / matches.length) * 100) : 0;
            return (
              <div key={val} className="flex items-center gap-4">
                <div className="w-20 font-mono">{val.toFixed(1)}ms</div>
                <div className="flex-1 bg-gray-700 h-6 rounded-full overflow-hidden">
                  <div className="bg-blue-500 h-full" style={{ width: `${pct}%` }}></div>
                </div>
                <div className="w-12 text-sm">{pct}%</div>
              </div>
            );
          })}
        </div>
        <textarea readOnly value={csvText} className="w-full h-40 mt-8 bg-black p-4 font-mono text-xs" />
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center justify-start pt-20 min-h-screen" style={{ backgroundColor: `rgb(${yellowR},${yellowG},${yellowB})` }}>
      <div className="mb-12 flex gap-8">
        <div className="w-64 h-64 rounded-full flex items-center justify-center bg-transparent">
          <div ref={leftEmojiRef} className="w-56 h-56 rounded-full" style={{ filter: 'blur(30px)' }}></div>
        </div>
        <div className="w-64 h-64 rounded-full flex items-center justify-center bg-transparent">
          <div ref={rightEmojiRef} className="w-56 h-56 rounded-full" style={{ filter: 'blur(30px)' }}></div>
        </div>
      </div>
      <div className="flex gap-4">
        {['Left', 'Same', 'Right'].map(btn => (
          <button key={btn} onPointerDown={() => handleResponse(btn)} disabled={phase !== 'response'} className="bg-gray-500 px-8 py-4 rounded-xl font-bold text-white disabled:opacity-30">
            {btn.toUpperCase()}
          </button>
        ))}
      </div>
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<SynchronyTest />);
  </script>
</body>
</html>
